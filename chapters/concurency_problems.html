<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"/>
	<meta name="description" content=""/>
	<meta name="keywords" content=""/>
	<title>Chapter_Name page</title>
	<link rel="stylesheet" href="../css/reset.css"/>
	<link rel="stylesheet" href="../css/chapter_style.css"/>
</head>
<body>
	<header>
		<h2 id="top">Concurrency Problems</h2>
	</header>
	  <div class="arrow">
    <a href="#top" title="go on top"></a>
  </div>
	<nav>
		<ul>
			<li>
				<a href="../index.html">Home</a>
			</li>
			<li>
				<a href="architecture.html">Architecture</a>
			</li>
			<li>
				<a href="making_a_choise.html">Making a Choise</a>
			</li>
			<li>
				<a href="view_patterns.html">View Patterns</a>
			</li>
			<li>
				<a href="application_server_concurrency.html">Application Server Concurrency</a>
			</li>
			<li>
				<a href="session_state.html">Session State</a>
			</li>
			<li>
				<a href="Optimistic_and_Pessimistic_Concurrency.html">Optimistic and Pessimistic Concurrency</a>
			</li>
			<li>
				<a href="#">Kings of enterprise application</a>
			</li>
		</ul>				
	</nav>
	<main>
		<p>We'll start by going through the essential problems of concurrency. We call them essential because they're
the fundamental problems that concurrency control systems try to prevent. They aren't the only problems of
concurrency, because the control mechanisms often create a new set of problems in their solutions!
However, they do focus on the essential point of concurrency control.</p>
		<p>Lost updatesare the simplest idea to understand. Say Martin edits a file to make some changes to the
checkConcurrencymethodâ€”a task that takes a few minutes. While he's doing this David alters the
updateImportantParametermethod in the same file. David starts and finishes his alteration very quickly,
so quickly that, even though he starts after Martin, he finishes before him. This is unfortunate. When Martin
read the file it didn't include David's update, so when Martin writes the file it writes over the version that
David updated and David's update is lost forever.</p>
			<p>An inconsistent readoccurs when you read two things that are correct pieces of information but not correct
at the same time. Say Martin wishes to know how many classes are in the concurrency package, which
contains two subpackages for locking and multiphase. Martin looks in the locking package and sees seven
classes. At this point he gets a phone call from Roy on some abstruse question. While Martin's answering the
phone, David finishes dealing with that pesky bug in the four-phase lock code and adds two classes to the
locking package and three classes to the five that were in the multiphase package. His phone call over,
Martin looks in the multiphase package to see how many classes there are and sees eight, producing a grand
total of fifteen.</p>
			<p>Sadly, fifteen classes was never the right answer. The correct answer was twelve before David's update and
seventeen afterward. Either answer would have been correct, even if not current, but fifteen was never
correct. This problem is called an inconsistent read because the data that Martin read was inconsistent.
Both of these problems cause a failure of correctness(or safety), and they result in incorrect behavior that
would not have occurred without two people trying to work with the same data at the same time. However, if
correctness were the only issue, these problems wouldn't be that serious. After all, we can arrange things so
that only one of us can work the data at one time. While this helps with correctness, it reduces the ability to
do things concurrently. The essential problem of any concurrent programming is that it's not enough to
worry about correctness; you also have to worry about liveness: how much concurrent activity can go on.
Often people need to sacrifice some correctness to gain more liveness, depending on the seriousness and
likelihood of the failures and the need for people to work on their data concurrently.</p>
			<p>These aren't all the problems you get with concurrency, but we think of these as the basic ones. To solve
them we use various control mechanisms. Alas, there's no free lunch. The solutions introduce problems of
their own, although these problems are less serious than the basic ones. Still, this does bring up an
important point: If you can tolerate the problems, you can avoid any form of concurrency control. This is
rare, but occasionally you find circumstances that permit it.</p>
	</main>	   
	<footer>
    <div id="copy">
      Copyright &copy; 2016 | Design: EL_PASO
    </div> 
  </footer>    	
</body>
</html>