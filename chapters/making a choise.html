<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8"/>
	<meta name="description" content=""/>
	<meta name="keywords" content=""/>
	<title>Chapter_Name page</title>
	<link rel="stylesheet" href="../css/reset.css"/>
	<link rel="stylesheet" href="../css/chapter_style.css"/>
</head>
<body>
		<div class="basic">  
		<header>
		<h2>Kinds of Enterprise Application</h2>
		</header>
		<section>
			<div class="chapter">;
			<a href="../index.html">
					<div class="block-m">	
						<div class="home">
							<h3>Home</h3>
						</div>
					</div>		
			</a>
			<a href="../chapters/architecture.html"">			
						<div class="block-m">
							<div class="arch">
							<h3>Architecture</h3>
							</div>
						</div>
			</a>
			<a href="../chapters/making a choise.html">
						<div class="block-m">	
							<div class="making">
							<h3>Making a Choise</h3>
							</div>
						</div>	
			</a>	
			<a href="../chapters/view patterns.html">
						<div class="block-m">
							<div class="view">
							<h3>View Patterns</h3>
							</div>
						</div>	
			</a>
			<a href="../chapters/concurency problems.html">
						<div class="block-m">		
							<div class="concurency">
							<h3>Concurency Problems</h3>
							</div>
						</div>
			</a>
			<a href="../chapters/application server concurrency.html">
						<div class="block-m">	
							<div class="application">
							<h3>Application Server Concurrency</h3>
							</div>
						</div>
			</a>
			<a href="../chapters/session state.html">													
						<div class="block-m">
							<div class="session">
							<h3>Session State</h3>
							</div>
						</div>
			</a>
			<a href="../chapters/Optimistic and Pessimistic Concurrency.html">			
						<div class="block-m">	
							<div class="optimistic">
							<h3>Optimistic and Pessimistic Concurrency</h3>
							</div>
						</div>
			</a>
			</div>
			<br>
			<p><span>Making a Choice</span></p>
			<br>
			<p>So, how do you choose between the three patterns? It's not an easy choice, and it very much depends on
how complex your domain logic is. Figure 2.4is one of those nonscientific graphs that really irritate me in
PowerPoint presentations because they have utterly unquantified axes. However, it helps to visualize my
sense of how the three compare. With simple domain logic the Domain Model(116)is less attractive because
the cost of understanding it and the complexity of the data source add a lot of effort to developing it that
won't be paid back. Nevertheless, as the complexity of the domain logic increases, the other approaches
tend to hit a wall where adding more features becomes exponentially more difficult.</p>
			<h4>Figure 2.4. A sense of the relationships between complexity and effort for different domain logic styles.</h4>
			<img src="../pictures/view_6.png" height="405" width="566">
			<p>Your problem, of course, is to figure out where on that xaxis your application lies. The good news is that I
can say that you should use a  Domain Model(116)whenever the complexity of your domain logic is greater
than 7.42. The bad news is that nobody knows how to measure the complexity of domain logic. In practice,
then, all you can do is find some experienced people who can do an initial analysis of the requirements and
make a judgment call.</p>
			<p>There are some factors that alter the curves a bit. A team that's familiar with Domain Model(116)will lower
the initial cost of using this pattern. It won't lower it to same starting point as the others because of the data
source complexity. Still, the better the team is, the more I'm inclined to use a Domain Model(116).
The attractiveness of a Table Module(125)depends very much on the support for a common Record Set
(508)structure in your environment. If you have an environment like .NET or Visual Studio, where lots of
tools work around a  Record Set(508),then that makes a Table Module(125)much more attractive. Indeed,
I don't see a reason to use Transaction Scripts(110)in a .NET environment. However, if there's no special
tooling for Record Sets(508),I wouldn't bother with Table Module(125).</p>
			<p>Once you've made it, your decision isn't completely cast in stone, but it is more tricky to change. So it's
worth some upfront thought to decide which way to go. If you find you went the wrong way, then, if you
started with Transaction Script(110),don't hesitate to refactor toward Domain Model(116).If you started
with Domain Model(116),however, going to Transaction Script(110)is usually less worthwhile unless you
can simplify your data source layer.</p>
			<p>These three patterns are not mutually exclusive choices. Indeed, it's quite common to use Transaction Script
(110)for some of the domain logic and Table Module(125)or Domain Model(116)for the rest.<p/>
			<p>A common approach in handling domain logic is to split the domain layer in two. A  Service Layer(133)is
placed over an underlying Domain Model(116)or Table Module(125).Usually you only get this with a
Domain Model(116)or Table Module(125)since a domain layer that uses only  Transaction Script(110)isn't
complex enough to warrant a separate layer. The presentation logic interacts with the domain purely through
the Service Layer(133),which acts as an API for the application.</p>
			<p>As well as providing a clear API, the Service Layer(133)is also a good spot to place such things as
transaction control and security. This gives you a simple model of taking each method in the Service Layer
(133)and describing its transactional and security characteristics. A separate properties file is a common
choice for this, but .NET's attributes provide a nice way of doing it directly in the code.</p>
			<p>When you see a Service Layer(133),a key decision is how much behavior to put in it. The minimal case is to
make the Service Layer(133)a facade so that all of the real behavior is in underlying objects and all the
Service Layer(133)does is forward calls on the facade to lower-level objects. In that case the Service Layer
(133)provides an API that's easier to use because it's typically oriented around use cases. It also makes a
convenient point for adding transactional wrappers and security checks.</p>
			<p>At the other extreme, most business logic is placed in Transaction Scripts(110)inside the Service Layer
(133).The underlying domain objects are very simple; if it's a Domain Model(116)it will be one-to-one with
the database and you can thus use a simpler data source layer such as  Active Record(160).</p>
			<p>Midway between these alternatives is a more even mix of behavior: the controller-entitystyle. This name
comes from a common practice influenced heavily by [Jacobson et al.]. The point here is to have logic that's
particular to a single transaction or use case placed in Transaction Scripts(110),which are commonly
referred to as controllers or services. These are different controllers to the input controller in Model View
Controller(330)or Application Controller(379)that we'll meet later, so I use the term use-case 
controller.Behavior that's used in more than one use case goes on the domain objects, which are called
entities.</p>
			<p>Although the controller-entity approach is a common one, it's not one that I've ever liked much. The use
case controllers, like any Transaction Script(110),tend to encourage duplicate code. My view is that, if you
decide to use a Domain Model(116)at all, you really should go whole hog and make it dominant. The one
exception to this is if you've started with a design that uses Transaction Script(110)with Row Data Gateway
(152).Then it makes sense to move duplicated behavior to the Row Data Gateways(152),which will turn
them into a simple Domain Model(116)using Active Record(160).However, I wouldn't start that way. I
would only do that to improve a design that's showing cracks.</p>
			<p>I'm saying not that you should never have service objects that contain business logic, but that you shouldn't
necessarily make a fixed layer of them. Procedural service objects can sometimes be a very useful way to
factor logic, but I tend to use them as needed rather than as an architectural layer.</p>
			<p>My preference is thus to have the thinnest Service Layer(133)you can, if you even need one. My usual
approach is to assume that I don't need one and only add it if it seems that the application needs it.
However, I know many good designers who always use a Service Layer(133)with a fair bit of logic, so feel
free to ignore me on this one. Randy Stafford has had a lot of success with a rich  Service Layer(133),which
is why I asked him to write the Service Layer(133)pattern for this book.</p>
		</div>	
		</section>																									<!--Footer-->    
	<footer>
       <div id="copy">
          Copyright @ 2016 | Design: EL_PASO
       </div> 
    </footer>    	
</body>
</html>